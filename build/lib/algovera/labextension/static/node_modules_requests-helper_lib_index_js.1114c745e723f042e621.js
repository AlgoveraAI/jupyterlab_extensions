"use strict";
(self["webpackChunkalgovera"] = self["webpackChunkalgovera"] || []).push([
  ["node_modules_requests-helper_lib_index_js"],
  {
    /***/ "./node_modules/requests-helper/lib/index.js":
      /*!***************************************************!*\
  !*** ./node_modules/requests-helper/lib/index.js ***!
  \***************************************************/
      /***/ (__unused_webpack_module, exports) => {
        Object.defineProperty(exports, "__esModule", { value: true });
        exports.DEFAULT_REQUEST_OPTIONS = {
          blob: false,
          headers: {
            Accept: "application/json, text/javascript, text/plain",
          },
          ignoreCache: false,
          // default max duration for a request
          timeout: 5000,
        };
        function queryParams(params = {}) {
          return Object.keys(params)
            .map(
              (k) => encodeURIComponent(k) + "=" + encodeURIComponent(params[k])
            )
            .join("&");
        }
        function withQuery(url, params = {}) {
          const queryString = queryParams(params);
          return queryString
            ? url + (url.indexOf("?") === -1 ? "?" : "&") + queryString
            : url;
        }
        function parseXHRResult(xhr, blob = false) {
          return {
            data: blob ? xhr.response : xhr.responseText,
            headers: xhr.getAllResponseHeaders(),
            json: () => JSON.parse(xhr.responseText),
            ok: xhr.status >= 200 && xhr.status < 300,
            status: xhr.status,
            statusText: xhr.statusText,
            url: xhr.responseURL,
          };
        }
        function errorResponse(xhr, message = null) {
          return {
            data: message || xhr.statusText,
            headers: xhr.getAllResponseHeaders(),
            json: () => JSON.parse(message || xhr.statusText),
            ok: false,
            status: xhr.status,
            statusText: xhr.statusText,
            url: xhr.responseURL,
          };
        }
        function request(
          method,
          url,
          queryParamsOther = {},
          body = null,
          options = exports.DEFAULT_REQUEST_OPTIONS
        ) {
          const ignoreCache =
            options.ignoreCache || exports.DEFAULT_REQUEST_OPTIONS.ignoreCache;
          const headers =
            options.headers || exports.DEFAULT_REQUEST_OPTIONS.headers;
          const timeout =
            options.timeout || exports.DEFAULT_REQUEST_OPTIONS.timeout;
          const blob = options.blob || exports.DEFAULT_REQUEST_OPTIONS.blob;
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open(method, withQuery(url, queryParamsOther));
            if (headers) {
              Object.keys(headers).forEach((key) =>
                xhr.setRequestHeader(key, headers[key])
              );
            }
            if (ignoreCache) {
              xhr.setRequestHeader("Cache-Control", "no-cache");
            }
            xhr.timeout = timeout;
            xhr.onload = (evt) => {
              resolve(parseXHRResult(xhr, blob));
            };
            xhr.onerror = (evt) => {
              resolve(errorResponse(xhr, "Failed to make request."));
            };
            xhr.ontimeout = (evt) => {
              resolve(errorResponse(xhr, "Request took longer than expected."));
            };
            if (method === "post" && body) {
              xhr.setRequestHeader("Content-Type", "application/json");
              xhr.send(JSON.stringify(body));
            } else {
              xhr.send();
            }
          });
        }
        exports.request = request;
        function requestFormData(url, formdata) {
          const options = exports.DEFAULT_REQUEST_OPTIONS;
          const ignoreCache =
            options.ignoreCache || exports.DEFAULT_REQUEST_OPTIONS.ignoreCache;
          const headers =
            options.headers || exports.DEFAULT_REQUEST_OPTIONS.headers;
          const timeout =
            options.timeout || exports.DEFAULT_REQUEST_OPTIONS.timeout;
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("post", withQuery(url, queryParams));
            Object.keys(headers).forEach((key) =>
              xhr.setRequestHeader(key, headers[key])
            );
            if (ignoreCache) {
              xhr.setRequestHeader("Cache-Control", "no-cache");
            }
            xhr.timeout = timeout;
            xhr.onload = (evt) => {
              resolve(parseXHRResult(xhr));
            };
            xhr.onerror = (evt) => {
              resolve(errorResponse(xhr, "Failed to make request."));
            };
            xhr.ontimeout = (evt) => {
              resolve(errorResponse(xhr, "Request took longer than expected."));
            };
            xhr.send(formdata);
          });
        }
        exports.requestFormData = requestFormData;

        /***/
      },
  },
]);
//# sourceMappingURL=node_modules_requests-helper_lib_index_js.1114c745e723f042e621.js.map
